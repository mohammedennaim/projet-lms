{"ast":null,"code":"// JWT utility functions for token decoding and role checking\n\n/**\r\n * Decode JWT token without verification (client-side only)\r\n * @param {string} token - JWT token\r\n * @returns {object|null} - Decoded payload or null if invalid\r\n */\nexport const decodeJwtToken = token => {\n  try {\n    if (!token) return null;\n\n    // JWT has 3 parts separated by dots\n    const parts = token.split('.');\n    if (parts.length !== 3) return null;\n\n    // Decode the payload (second part)\n    const payload = parts[1];\n    // Add padding if needed for base64 decoding\n    const paddedPayload = payload + '='.repeat((4 - payload.length % 4) % 4);\n\n    // Decode base64\n    const decodedPayload = atob(paddedPayload.replace(/-/g, '+').replace(/_/g, '/'));\n    return JSON.parse(decodedPayload);\n  } catch (error) {\n    console.error('Failed to decode JWT token:', error);\n    return null;\n  }\n};\n\n/**\r\n * Get user roles from JWT token\r\n * @param {string} token - JWT token\r\n * @returns {array} - Array of user roles\r\n */\nexport const getUserRolesFromToken = token => {\n  const payload = decodeJwtToken(token);\n  if (!payload) return [];\n\n  // The JWT payload should contain roles\n  return payload.roles || [];\n};\n\n/**\r\n * Check if user has admin role\r\n * @param {string} token - JWT token\r\n * @returns {boolean} - True if user is admin\r\n */\nexport const isAdminUser = token => {\n  const roles = getUserRolesFromToken(token);\n  return roles.includes('ROLE_ADMIN');\n};\n\n/**\r\n * Check if user has specific role\r\n * @param {string} token - JWT token\r\n * @param {string} role - Role to check\r\n * @returns {boolean} - True if user has the role\r\n */\nexport const hasRole = (token, role) => {\n  const roles = getUserRolesFromToken(token);\n  return roles.includes(role);\n};\n\n/**\r\n * Get user information from token\r\n * @param {string} token - JWT token\r\n * @returns {object|null} - User info or null\r\n */\nexport const getUserFromToken = token => {\n  const payload = decodeJwtToken(token);\n  if (!payload) return null;\n  return {\n    email: payload.username || payload.email,\n    roles: payload.roles || [],\n    exp: payload.exp,\n    iat: payload.iat\n  };\n};\n\n/**\r\n * Check if token is expired\r\n * @param {string} token - JWT token\r\n * @returns {boolean} - True if token is expired\r\n */\nexport const isTokenExpired = token => {\n  const payload = decodeJwtToken(token);\n  if (!payload || !payload.exp) return true;\n  const now = Math.floor(Date.now() / 1000);\n  return payload.exp < now;\n};","map":{"version":3,"names":["decodeJwtToken","token","parts","split","length","payload","paddedPayload","repeat","decodedPayload","atob","replace","JSON","parse","error","console","getUserRolesFromToken","roles","isAdminUser","includes","hasRole","role","getUserFromToken","email","username","exp","iat","isTokenExpired","now","Math","floor","Date"],"sources":["C:/Users/Youcode/Desktop/lms/projet-lms/FrontEnd/src/utils/jwtUtils.js"],"sourcesContent":["// JWT utility functions for token decoding and role checking\r\n\r\n/**\r\n * Decode JWT token without verification (client-side only)\r\n * @param {string} token - JWT token\r\n * @returns {object|null} - Decoded payload or null if invalid\r\n */\r\nexport const decodeJwtToken = (token) => {\r\n  try {\r\n    if (!token) return null;\r\n    \r\n    // JWT has 3 parts separated by dots\r\n    const parts = token.split('.');\r\n    if (parts.length !== 3) return null;\r\n    \r\n    // Decode the payload (second part)\r\n    const payload = parts[1];\r\n    // Add padding if needed for base64 decoding\r\n    const paddedPayload = payload + '='.repeat((4 - payload.length % 4) % 4);\r\n    \r\n    // Decode base64\r\n    const decodedPayload = atob(paddedPayload.replace(/-/g, '+').replace(/_/g, '/'));\r\n    \r\n    return JSON.parse(decodedPayload);\r\n  } catch (error) {\r\n    console.error('Failed to decode JWT token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Get user roles from JWT token\r\n * @param {string} token - JWT token\r\n * @returns {array} - Array of user roles\r\n */\r\nexport const getUserRolesFromToken = (token) => {\r\n  const payload = decodeJwtToken(token);\r\n  if (!payload) return [];\r\n  \r\n  // The JWT payload should contain roles\r\n  return payload.roles || [];\r\n};\r\n\r\n/**\r\n * Check if user has admin role\r\n * @param {string} token - JWT token\r\n * @returns {boolean} - True if user is admin\r\n */\r\nexport const isAdminUser = (token) => {\r\n  const roles = getUserRolesFromToken(token);\r\n  return roles.includes('ROLE_ADMIN');\r\n};\r\n\r\n/**\r\n * Check if user has specific role\r\n * @param {string} token - JWT token\r\n * @param {string} role - Role to check\r\n * @returns {boolean} - True if user has the role\r\n */\r\nexport const hasRole = (token, role) => {\r\n  const roles = getUserRolesFromToken(token);\r\n  return roles.includes(role);\r\n};\r\n\r\n/**\r\n * Get user information from token\r\n * @param {string} token - JWT token\r\n * @returns {object|null} - User info or null\r\n */\r\nexport const getUserFromToken = (token) => {\r\n  const payload = decodeJwtToken(token);\r\n  if (!payload) return null;\r\n  \r\n  return {\r\n    email: payload.username || payload.email,\r\n    roles: payload.roles || [],\r\n    exp: payload.exp,\r\n    iat: payload.iat\r\n  };\r\n};\r\n\r\n/**\r\n * Check if token is expired\r\n * @param {string} token - JWT token\r\n * @returns {boolean} - True if token is expired\r\n */\r\nexport const isTokenExpired = (token) => {\r\n  const payload = decodeJwtToken(token);\r\n  if (!payload || !payload.exp) return true;\r\n  \r\n  const now = Math.floor(Date.now() / 1000);\r\n  return payload.exp < now;\r\n};\r\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,cAAc,GAAIC,KAAK,IAAK;EACvC,IAAI;IACF,IAAI,CAACA,KAAK,EAAE,OAAO,IAAI;;IAEvB;IACA,MAAMC,KAAK,GAAGD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;;IAEnC;IACA,MAAMC,OAAO,GAAGH,KAAK,CAAC,CAAC,CAAC;IACxB;IACA,MAAMI,aAAa,GAAGD,OAAO,GAAG,GAAG,CAACE,MAAM,CAAC,CAAC,CAAC,GAAGF,OAAO,CAACD,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;;IAExE;IACA,MAAMI,cAAc,GAAGC,IAAI,CAACH,aAAa,CAACI,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IAEhF,OAAOC,IAAI,CAACC,KAAK,CAACJ,cAAc,CAAC;EACnC,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,qBAAqB,GAAId,KAAK,IAAK;EAC9C,MAAMI,OAAO,GAAGL,cAAc,CAACC,KAAK,CAAC;EACrC,IAAI,CAACI,OAAO,EAAE,OAAO,EAAE;;EAEvB;EACA,OAAOA,OAAO,CAACW,KAAK,IAAI,EAAE;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAIhB,KAAK,IAAK;EACpC,MAAMe,KAAK,GAAGD,qBAAqB,CAACd,KAAK,CAAC;EAC1C,OAAOe,KAAK,CAACE,QAAQ,CAAC,YAAY,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGA,CAAClB,KAAK,EAAEmB,IAAI,KAAK;EACtC,MAAMJ,KAAK,GAAGD,qBAAqB,CAACd,KAAK,CAAC;EAC1C,OAAOe,KAAK,CAACE,QAAQ,CAACE,IAAI,CAAC;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAIpB,KAAK,IAAK;EACzC,MAAMI,OAAO,GAAGL,cAAc,CAACC,KAAK,CAAC;EACrC,IAAI,CAACI,OAAO,EAAE,OAAO,IAAI;EAEzB,OAAO;IACLiB,KAAK,EAAEjB,OAAO,CAACkB,QAAQ,IAAIlB,OAAO,CAACiB,KAAK;IACxCN,KAAK,EAAEX,OAAO,CAACW,KAAK,IAAI,EAAE;IAC1BQ,GAAG,EAAEnB,OAAO,CAACmB,GAAG;IAChBC,GAAG,EAAEpB,OAAO,CAACoB;EACf,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAIzB,KAAK,IAAK;EACvC,MAAMI,OAAO,GAAGL,cAAc,CAACC,KAAK,CAAC;EACrC,IAAI,CAACI,OAAO,IAAI,CAACA,OAAO,CAACmB,GAAG,EAAE,OAAO,IAAI;EAEzC,MAAMG,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACH,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;EACzC,OAAOtB,OAAO,CAACmB,GAAG,GAAGG,GAAG;AAC1B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}